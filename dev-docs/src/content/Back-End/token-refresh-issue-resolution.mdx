# Token Refresh 문제 해결 리포트

## 1. 문제 상황 분석

### 1.1 발생한 문제
- **증상**: Feed 앱에서 Workspace 앱으로 이동 시 access token 만료로 인한 401 Unauthorized 에러 발생
- **원인**: `/auth/token/access` API 호출 시 "쿠키에서 refresh 토큰을 찾을 수 없다"는 에러 메시지

### 1.2 근본 원인 분석

#### **LocalStorage → Cookie 전환의 부작용**
```typescript
// Before (LocalStorage 기반)
- Access token이 만료되어도 클라이언트에 계속 존재
- Interceptor에서 401 에러 감지 후 토큰 재발급 처리

// After (Cookie 기반)  
- Access token이 maxAge(15분) 후 자동 소멸
- Global AccessTokenGuard가 토큰 부재 시 즉시 401 에러 발생
```

#### **Guard 실행 순서 문제**
1. **Global AccessTokenGuard** 실행 → access_token 쿠키 없음 → 즉시 실패
2. **Client Interceptor** 실행 기회 없음 → 토큰 재발급 불가능
3. **RefreshTokenGuard** 도달 불가능 → 정상적인 refresh 로직 작동 안함

## 2. 해결 방안

### 2.1 설계 방향
**핵심 아이디어**: Server-side에서 토큰 생명주기 완전 관리

### 2.2 구현 세부사항

#### **BearerTokenGuard 개선**
```typescript
// Before: 무조건 access token 요구
const token = this.authService.extractTokenFromCookies(request, 'access');

// After: 유연한 토큰 처리
const accessToken = request.cookies?.access_token;
const refreshToken = request.cookies?.refresh_token;

// validateAuthTokens 로직 통합
this.authService.validateAuthTokens(accessToken, refreshToken, response);
```

#### **토큰 검증 로직 통합**
```typescript
// Case 1: 둘 다 있고 유효 → 통과
// Case 2: access 만료, refresh 유효 → 자동 재발급 후 통과  
// Case 3: access 없음, refresh 유효 → 새로 발급 후 통과
// Case 4: refresh도 없거나 만료 → 401 에러
```

## 3. 해결 결과

### 3.1 즉시적 효과
- ✅ **토큰 만료 에러 해결**: Access token 자동 소멸 시에도 정상 작동
- ✅ **앱 간 이동 원활**: Feed ↔ Workspace 전환 시 인증 문제 없음
- ✅ **사용자 경험 개선**: 로그인 상태 유지, 재로그인 불필요

### 3.2 시스템 아키텍처 개선

#### **Before (Client-Server 분산 관리)**
```
Client Interceptor ←→ Server Guard
     ↓                    ↓
토큰 재발급 로직        토큰 검증만
```

#### **After (Server 중심 관리)**
```
Server Guard Only
     ↓
토큰 검증 + 자동 재발급
```

## 4. 장점 및 이점

### 4.1 보안성 향상
- **토큰 관리 일원화**: 모든 토큰 로직이 서버에서 처리
- **일관된 보안 정책**: 모든 API 요청이 동일한 방식으로 검증
- **토큰 노출 위험 감소**: 클라이언트에서 토큰 조작 불가능

### 4.2 개발 복잡도 감소
- **Client-side 단순화**: Interceptor 토큰 재발급 로직 제거 가능
- **코드 중복 제거**: 토큰 검증 로직이 한 곳에 집중
- **디버깅 용이성**: 토큰 관련 이슈를 서버에서만 추적

### 4.3 사용자 경험 개선
- **투명한 토큰 갱신**: 사용자가 토큰 만료를 인지하지 못함
- **끊김 없는 서비스**: 세션 유지 중 재로그인 불필요
- **빠른 응답**: Client-server 왕복 없이 즉시 처리

### 4.4 유지보수성 향상
- **단일 책임**: Guard가 인증과 토큰 관리 모두 담당
- **확장성**: 새로운 토큰 정책 추가 시 한 곳만 수정
- **테스트 단순화**: 서버 측 로직만 테스트하면 됨

## 5. 기술적 세부사항

### 5.1 제거 가능한 코드
```typescript
// packages/axios-client/src/interceptors.ts
export const rotateAccessToken = async () => { ... } // 불필요
```

### 5.2 핵심 변경사항
```typescript
// server/nest-api/src/auth/guard/bearer-token.guard.ts
async canActivate(context: ExecutionContext): Promise<boolean> {
  // 쿠키 기반 토큰 추출
  const accessToken = request.cookies?.access_token;
  const refreshToken = request.cookies?.refresh_token;
  
  // 자동 토큰 갱신
  this.authService.validateAuthTokens(accessToken, refreshToken, response);
  
  // 새로운 토큰으로 사용자 인증
  // ...
}
```

## 6. 결론

이번 수정을 통해 **Cookie 기반 토큰 시스템의 자동 소멸 특성을 활용**하면서도, **Server-side 자동 갱신 메커니즘**으로 사용자 경험을 보장하는 robust한 인증 시스템을 구축했습니다.

**핵심 성과**:
- 토큰 만료로 인한 서비스 중단 방지
- 클라이언트 코드 복잡도 감소  
- 보안성과 사용자 경험 동시 향상
- 장기적 유지보수성 확보